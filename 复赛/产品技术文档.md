# 产品技术文档

## LLM-ECO-VIZ：开源AI大模型生态分析与可视化 

## 前言

​	请读者注意，本文档的主要目的是向**开发者**全方位地展现`LLM-ECO-VIZ`项目的**项目结构**、**数据来源**、**设计思路**等**技术细节**。若只想了解如何使用本产品，请移步[产品使用文档](产品使用文档.md)。在读本文档前，请先读[产品使用文档](产品使用文档.md)深入了解本项目的实现效果。

​	我们的[复赛ppt](复赛.pptx)融合了我们所有文档的内容并包含动图演示，可供读者参考。

​	为洞察大模型领域的开原生态情况，本项目基于GitHub和Hugging Face两个开源社区的活动数据，对两个社区的大模型领域开源项目进行了生态分析与可视化。从开发者的视角来看，项目的文件结构如下：

```plaintext
LLM-ECO-VIZ
├── data_fetching/          # 数据获取相关代码
│   ├── author_metadata/     # 获取模型作者元数据
│   ├── fetching_model_tree/ # 获取模型及其衍生关系树
│   ├── find_basemodel/      # 获取基础模型数据
│   ├── llm_github_data/     # GitHub相关LLM数据（如项目分类）
│   ├── model_metadata/      # 模型元数据获取
│   ├── space_metadata/      # Space相关元数据获取
│   └── output/              # 存储各部分生成的输出文件
├── data_hf/                # 用于处理Hugging Face数据
│   ├── graph_computing.py   # 图构建及影响力计算
├── frontend/               # 前端文件夹（使用Next.js）
│   ├── pages/               # 页面组件
│   ├── styles/              # 样式文件
│   └── public/              # 静态资源
├── viz_hf/                 # Hugging Face数据可视化
│   ├── global_dashboard/    # 生态全局数据大屏
│   ├── leaderboard/         # LLM Leaderboard
│   ├── network_graph/       # 网络关系图相关代码
│   ├── static/              # 静态资源
│   ├── templates/           # 前端模板（用于Flask）
│   ├── app.py               # Flask主程序入口
│   ├── config.py            # 配置文件
│   ├── graph.pkl            # 预处理后的图数据
│   └── requirements.txt     # 后端依赖文件
├── img/                    # 图片存储文件夹

```

​	每个文件夹的具体内容可通过文件夹内的README查看。

## 目录

- [一、GitHub部分](#一github部分)
- [二、Hugging Face部分](#二hugging-face部分)
  - [1. 数据获取](#1-数据获取)
  - [2. 用Easy Graph构造图](#2-用easy-graph构造图)
    - [图结构定义](#图结构定义)
    - [节点属性](#节点属性)
    - [边属性](#边属性)
  - [3. 影响力计算](#3-影响力计算)
    - [1. 自身影响力计算](#1-自身影响力计算)
    - [2. 总影响力计算](#2-总影响力计算)
    - [3. 算法迭代步骤](#3-算法迭代步骤)
    - [4. 参数说明](#4-参数说明)
  - [4. 用PyVis绘制关系网络图](#4-用pyvis绘制关系网络图)

## 一、GitHub部分

​	GitHub部分的数据来自于OpenDigger，静态数据根链接为 `https://oss.open-digger.cn/{platform}/{org/login}/{repo}/`。本部分的分析覆盖了 OpenDigger 上的`labeled_data`的大模型有关的所有项目。本部分通过 Next.js 构建并部署。通过深入分析GitHub数据，我们提供了全方位的开源项目洞察， 包括贡献者网络分析、影响力评估、活跃度追踪等多个维度。帮助开发者更好地理解AI开源生态系统的发展动态。

## 二、Hugging Face部分

### 1. 数据获取

​	我们Hugging Face上的数据的来源有两处：一为`huggingface_api`，二是通过爬虫爬取Hugging Face官网上的数据。下面我们将从数据获得的先后顺序来介绍我们的数据源的获取。所有获取数据的文件存放于`data_fetching/`中。

- `find_basemodel/` - 用`huggingface_api`获取点赞量排名前1000的模型名称
- `fetching_model_tree/` - 用爬虫获取点赞量排名前1000的模型的衍生模型
- `model_metadata/` - 用`huggingface_api`获取点赞量排名前1000的模型及其衍生模型的元数据
- `author_metadata/` - 用爬虫获取点赞量排名前1000的模型及其衍生模型的作者的元数据
- `space_metadata/` - 用爬虫获取`huggingface_api`获取相关模型space应用的元数据

各部分输出存放在各自文件夹的`output`文件夹下。

### 2. 用Easy Graph构造图

​	在`data_hf/`文件夹下，我们用Easy Graph构建起了大模型的关系图。它的本质是一个有向图。构建过程可参考`data_hf/graph_computing.py`的`build_graph()`函数。

- 一个结点表示一个模型
- 结点A指向结点B当且仅当B是A的衍生模型
- 结点的属性包括：下载量、点赞数、作者名称、作者的全名、作者的组织性质、模型创建日期、模型支持的语言、模型制作的spaces列表、模型的图标链接、作者的类型、模型的任务类型以及影响力。其中，影响力这一指标需要在整个图构建完成后再计算，后面会提到
- 边的属性包括：衍生模型的类型

### 3. 影响力计算

​	在`data_hf/graph_computing.py`中，我们设计了影响力算法。

根据您提供的代码，您的影响力算法是一个迭代过程，它结合了节点自身的属性、子节点（直接后继节点）的反馈以及父节点（直接前驱节点）的影响来评估每个节点在整个图中的影响力。这个过程考虑到了时间衰减因素，并且对不同类型的影响力分配了不同的权重。下面是该算法表达式的详细描述：


##### 1. 自身影响力计算

每个节点的自身影响力通过以下公式计算：

$$
I_{\text{self}} = W_1 \cdot \log(\max(\text{downloads}, 1)) + W_2 \cdot \text{likes} + W_3 \cdot I_{\text{spaces}} + W_4 \cdot e^{-\lambda \cdot \text{days\_since\_created}}
$$

其中：
- $\I_{\text{spaces}}$ 表示节点关联的 Spaces 的总影响力。
- $W_1, W_2, W_3, W_4$ 分别为自身影响力的分项权重参数。
- $\lambda$ 为时间衰减因子。
- $\text{days\_since\_created}$ 表示节点创建至今的天数。

##### Spaces 总影响力计算

$$
I_{\text{spaces}} = \sum_{\text{space} \in \text{spaces}} \text{likes}_{\text{space}} \cdot e^{-\lambda \cdot \text{days\_since\_created\_space}}
$$

其中：
- $\text{likes}_{\text{space}}$ 为 Space 的点赞数。
- $\text{days\_since\_created\_space}$ 为 Space 创建至今的天数。

---

##### 2. 总影响力计算

每个节点的总影响力由以下三部分组成：
1. 自身影响力。
2. 子模型传播的影响力。
3. 父模型传播的影响力。

##### 公式

$$
I_{\text{total}} = \alpha_1 \cdot I_{\text{self}} + \alpha_2 \cdot I_{\text{child}} + \alpha_3 \cdot I_{\text{parent}}
$$

其中：
- $I_{\text{self}}$ 为自身影响力。
- $I_{\text{child}}$ 为子模型传播的影响力，计算公式如下：
  $$
  I_{\text{child}} = \frac{1}{\max(1, |\text{children}|)} \sum_{\text{child} \in \text{children}} w_{\text{child}} \cdot I_{\text{child}}
  $$
  $w_{\text{child}}$ 表示从当前节点到子节点的权重。

- $I_{\text{parent}}$ 为父模型传播的影响力，计算公式如下：
  $$
  I_{\text{parent}} = \frac{1}{\max(1, |\text{parents}|)} \sum_{\text{parent} \in \text{parents}} w_{\text{parent}} \cdot I_{\text{parent}}
  $$
  $w_{\text{parent}}$ 表示从父节点到当前节点的权重。

---

##### 3. 算法迭代步骤

1. 初始化：将每个节点的初始影响力设置为其自身影响力：
   $$
   I_{\text{initial}}(v) = I_{\text{self}}(v)
   $$

2. 迭代更新影响力值：
   对每个节点，计算其新的总影响力：
   $$
   I_{\text{total,new}}(v) = \alpha_1 \cdot I_{\text{self}}(v) + \alpha_2 \cdot I_{\text{child}}(v) + \alpha_3 \cdot I_{\text{parent}}(v)
   $$

3. 计算总误差：
   $$
   \text{diff} = \sum_{v \in \text{nodes}} |I_{\text{total,new}}(v) - I_{\text{total,old}}(v)|
   $$

4. 判断收敛：
   如果 $\text{diff} < \text{tol}$，则认为算法收敛。

5. 更新影响力值，进入下一次迭代。

---

##### 4. 参数说明

- & \alpha_1, \alpha_2, \alpha_3 &：分别为自身影响力、子模型影响力、父模型影响力的权重参数。
- $W_1, W_2, W_3, W_4$：自身影响力的分项权重。
- $\lambda$：时间衰减因子。
- $\text{tol}$：收敛误差阈值。
- $\text{max\_iter}$：最大迭代次数。

整个算法通过迭代更新每个节点的影响力直至收敛或达到最大迭代次数为止。每次迭代都会根据最新的影响力值重新计算，并检查与上一次迭代之间的差异是否小于预设阈值来判断是否停止迭代。

​	为每个结点设置好影响力后，整个图对象的构造已完毕，我们将图对象保存为`pkl`格式到`viz_hf/`文件夹中，用于后续的可视化。

### 4. 用PyVis绘制关系网络图

​	我们采用 PyVis 库进行关系网络图的可视化绘制。此外，基于已有的这些数据，我们还构建了 LLM Leaderboard 以及 大模型生态大屏，将我们的项目变得更像一个生态分析的应用。我们使用 Flask 框架将其部署为一个 Web 应用。最终展示的实际效果请见产品使用文档！